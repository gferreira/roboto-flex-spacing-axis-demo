Roboto Flex SPAC
================

Adding a spacing axis to [Roboto Flex] using the [VariableSpacing] tools and data format.


Contents of this repository
---------------------------

```
Roboto Flex SPAC
├── scripts
│   └── *.py
├── spacing states
│   └── *.json
├── index.html
└── Roboto-Flex_SPAC.ttf
```

<dl>
<dt>scripts
<dd>various scripts to transform the UFO sources and build the variable font
<dt>spacing states
<dd>spacing state data in JSON format for all sources
<dt><a href='http://gferreira.github.io/roboto-flex-spacing-axis-demo/'>index.html</a>
<dd>comparison between spacing axis and tracking
<dt>Roboto-Flex_SPAC.ttf
<dd>custom Roboto Flex variable font with a spacing axis
</dl>


About the project
-----------------

Roboto Flex SPAC is an experimental version of [Roboto Flex] which includes an additional *spacing* axis (`SPAC`).

The spacing axis offers a new way to modify the default spacing of a font. While the automatic tracking function provided by applications adds a fixed value to all glyph widths, the spacing axis allows the designer to define **proportional** changes to the glyph margins, and use a different set of kerning values as well.


Notes on the workflow
---------------------

Roboto Flex SPAC is built on top of the sources and designspace of Roboto Flex.

1. For each source in the `Mains`, `Duovars` and `Trivars` folders, with the exception of `GRAD` sources, two new “tight” and “loose” spacing sources are created. This process is assisted by a new set of tools and a custom data format.

2. The original designspace is extended with the addition of a new *spacing* axis (`SPAC`), and the insertion of all new “tight” and “loose” spacing sources produced in step (1) in their appropriate min/max locations on that axis.

3. A variable font is then generated from this new designspace using the standard `fontmake` pipeline.

4. The new Roboto Flex SPAC can be compared to Roboto Flex using a [custom testing page](http://gferreira.github.io/roboto-flex-spacing-axis-demo/) which synchronizes the spacing axis value in the first with the tracking value in the second, and vice-versa.

### Creation of “tight” and “loose” spacing states

Variations of the default spacing are created by the designer with help of [VariableSpacing] tools. During the design stage, all the different versions of a font’s spacing can be stored inside the same UFO source. When it’s time to generate a variable font, these different *spacing states* are exported as separate UFOs.

It is essential that the width of the `space` glyph remains unaltered accross spacing states, as it is the reference point for all spacing variation. If a change to the width of the space is needed, it must be implemented through a separate mechanism (for example as a separate axis, or provided automatically by an application).  

It is also important that values in the spacing axis are more or less equivalent to tracking values in terms of overall text color. That is, setting the spacing axis value to `-50` should produce the same perceived tightness as setting tracking to `-50`. The optimal values were found with help of the testing page after a few iterations.

### The “tight” spacing state

In the *tight* spacing state, glyphs can almost touch. The font’s default spacing was modified by the designer using the tool [smart set margins](https://hipertipo.gitlab.io/VariableSpacing/set-margins-tool/), which reduces all glyph margins to a desired value (in this case 10 units) while making sure that all components stay in place. Some glyphs like `i`, `j`, `f` need a second manual pass using a horizontal beam to measure margins at specific vertical positions.

The bottleneck of the whole workflow is defining the tight kerning values. A script (which employs the collision-detection code of the [Touché](http://github.com/ninastoessinger/Touche) extension) can be used to approximate the results, which then still need to be checked visually and fine-tuned by hand, for all sources. The designer must make aesthetic decisions about which glyph pairs are allowed to touch and produce ligatures (for example `TV`, `KY`, `LX` etc), and which don’t – there is no additional parameter to control this aspect (as there is in [HEX Franklin Tyght](http://hex.xyz/HEX_Franklin/Tyght/), for example).

For the purpose of this demonstation, only basic tight kerning was created for combinations of UC/UC, UC/lc and lc/lc. This work was done manually and was very time-consuming. The full implementation of tight kerning in all sources would require some form of automation, as provided by tools like [iKern](http://www.ikern.space), [KernOn](https://kern-on.com), or similar.

### The “loose” spacing state

In the *loose* spacing state, the space between glyphs is almost as large as the word space. The font’s default spacing is modified automatically with a script, using an approach similar to positive tracking: a fixed number of units is added to the margins of all glyphs. The kerning values were not changed (maybe they should be).

### Updating the font

During development, the spacing states are stored inside the Roboto Flex sources for convenience. They can also be exported to separate data files. If the original Roboto Flex files change, we can import the spacing states from these data files on top of the new sources to create a fresh version of Roboto Flex SPAC.

### Remaining issues

There is currently no special handling for ligature and digraph glyphs, which look odd when the spacing axis value is close to the minimum (tight) or maximum (loose) ends of the axis. In comparison, automatic tracking usually disables ligatures when tracking exceeds a certain value. Similar behavior could be implemented in the spacing axis by adding glyph shape variations to spacing states – for more info see [add support for glyph shape variation along the spacing axis](https://github.com/gferreira/VariableSpacing/issues/5).


[Roboto Flex]: http://github.com/googlefonts/roboto-flex
[VariableSpacing]: http://github.com/gferreira/fb-variable-spacing

